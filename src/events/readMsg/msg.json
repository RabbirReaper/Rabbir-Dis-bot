{
    "draw": [
        "大吉",
        "小吉",
        "吉",
        "半吉",
        "末吉",
        "末小吉",
        "凶",
        "小凶",
        "半凶",
        "末凶",
        "大凶"
    ],
    "ans_key": [
        "P-6-2.",
        "P-6-3.",
        "Q-6-4.",
        "P-4-13.",
        "Q-6-5.",
        "P-6-7.",
        "Q-6-8.",
        "P-6-9.",
        "Q-6-10.",
        "Q-6-12.",
        "P-3-8.",
        "P-6-13.",
        "P-4-12.",
        "Q-6-14.",
        "P-6-20.",
        "Q-1-2.",
        "Q-1-4.",
        "Q-1-5.",
        "Q-1-8.",
        "Q-1-10.",
        "Q-2-7.",
        "Q-3-5.",
        "Q-3-11.",
        "Q-3-12.",
        "Q-4-6.",
        "Q-4-8.",
        "Q-4-10.",
        "Q-4-17.",
        "Q-4-16.",
        "Q-4-18.",
        "Q-4-19.",
        "Q-4-20.",
        "Q-5-5.",
        "Q-5-8.",
        "Q-7-5.",
        "Q-7-11.",
        "Q-8-6.",
        "Q-8-9.",
        "Q-8-12.",
        "Q-8-15."
    ],
    "ans_value": [
        "不連續的表演酬勞 ```\nint main() {\n    int n;\n    while(cin>>n){\n        int a[n],dp[n];\n        for(int i=0;i<n;i++){\n            cin>>a[i];\n        }\n        for(int i=0;i<n;i++){\n            if(i==0){\n                dp[i]=a[i];\n            }else{\n                if(i>=2)\n                    dp[i]=max(a[i]+dp[i-2],dp[i-1]);\n                else\n                   dp[i]=max(a[i],dp[i-1]);\n            }\n        }\n        cout<<dp[n-1]<<\"\\n\";\n    }\n\n    return 0;\n}```",
        "最小監控鄰居的成本 ```\nint main() {\n    int n;\n    while(cin>>n){\n        int a[n],dp[n];\n        for(int i=0;i<n;i++){\n            cin>>a[i];\n        }\n        dp[0]=a[0];\n        dp[1]=a[1];\n        dp[2]=a[2]+min(dp[1],dp[0]);\n        for(int i=3;i<n;i++){\n            dp[i]=a[i]+min(min(dp[i-1],dp[i-2]),dp[i-3]);\n        }\n        cout<<min(dp[n-1],dp[n-2])<<\"\\n\";\n    }\n\n    return 0;\n}```",
        "闖關二選一 ```int main() {\n    int n,t;\n    while(cin>>n>>t){\n            int dp[n][2],a[n],b[n];\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i];\n            if(i==0){\n                dp[i][0]=abs(a[i]-t);\n                dp[i][1]=abs(b[i]-t);\n            }else{\n                dp[i][0]=min(abs(a[i]-a[i-1])+dp[i-1][0],abs(a[i]-b[i-1])+dp[i-1][1]);\n                dp[i][1]=min(abs(b[i]-a[i-1])+dp[i-1][0],abs(b[i]-b[i-1])+dp[i-1][1]);\n            }\n        }\n        cout<<min(dp[n-1][0],dp[n-1][1]);\n    }\n\n    return 0;\n}```",
        "最大連續子陣列```#include <bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nint main() {\n    int n;\n    while(cin>>n){\n        LL dp[n],mx=0;\n        for(int i=0;i<n;i++){\n            LL t;\n            cin>>t;\n            if(i==0){\n                dp[i]=t;\n                mx=t;\n            }else{\n                dp[i]=max(t,dp[i-1]+t);\n                mx=max(mx,dp[i]);\n            }\n        }\n        if(mx<0) cout<<\"0\";\n        else cout<<\"\\n\"<<mx<<\"\\n\";\n    }\n    return 0;\n}```",
        "二維最大子矩陣```#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define N 205\nint main(){\n    int n,m;\n    cin>>n>>m;\n    int a[N][N],p[N][N];\n    for(int i=0;i<m;i++)\n        a[0][i]=0;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<m;j++){\n            cin>>a[i][j];\n            p[i][j]=p[i-1][j]+a[i][j];\n        }\n    }\n    LL mx=0;\n    for(int i=0;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            LL sum=0;\n            for(int k=0;k<m;k++){\n                sum+=p[j][k]-p[i][k];\n                if(sum<0) sum=0;\n                mx=max(mx,sum);\n            }\n        }\n    }\n    cout<<mx;\n    return 0;\n}```",
        "LCS ```#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define N 505\nint main(){\n    int lcs[N][N];\n    char a[N],b[N];\n    cin>>a>>b;\n    int n=strlen(a),m=strlen(b);\n    memset(lcs,0,sizeof(lcs));\n    for(int i=1;i<=m;i++){\n        for(int j=1;j<=n;j++){\n            if(a[j-1]==b[i-1])\n                lcs[i][j] = lcs[i-1][j-1]+1;\n            else\n                lcs[i][j]=max(lcs[i-1][j], lcs[i][j-1]);\n            //cout<<lcs[i][j]<<\" \";\n        }\n        //cout<<\"\\n\";\n    }\n    cout<<lcs[m][n];\n    return 0;\n}\n```",
        "Local alignment```#include<bits/stdc++.h>\nusing namespace std;\n#define N 505\nint main(){\n    int lcs[N][N],mx=0;\n    char a[N],b[N];\n    cin>>a>>b;\n    int n=max(strlen(a),strlen(b));\n    memset(lcs,0,sizeof(lcs));\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            if(a[i-1]==b[j-1])\n                lcs[i][j]=lcs[i-1][j-1]+8;\n            else\n                lcs[i][j]=max(lcs[i-1][j]-3, max(lcs[i][j-1]-3,lcs[i-1][j-1]-5));\n            if(lcs[i][j]<0) lcs[i][j]=0;\n            mx=max(mx,lcs[i][j]);\n            //cout<<setw(2)<<lcs[i][j]<<\" \";\n\n        }\n        //cout<<\"\\n\";\n    }\n    cout<<mx<<\"\\n\";\n    return 0;\n}```",
        "大賣場免費大搬家```#include<bits/stdc++.h>\nusing namespace std;\n#define N 101\n#define W 100005\nint dp[N][W]={0};\nint main(){\n    int n,w,a[N],b[N];\n    cin>>n>>w;\n    for(int i=0;i<n;i++)\n        cin>>a[i];\n    for(int i=0;i<n;i++)\n        cin>>b[i];\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<a[i-1];j++){\n            dp[i][j]=dp[i-1][j];\n            cout<<dp[i][j]<<\" \";\n        }\n        for(int j=a[i-1];j<=w;j++){\n            dp[i][j]=max(dp[i-1][j],dp[i-1][j-a[i-1]]+b[i-1]);\n            //cout<<dp[i][j]<<\" \";\n        }\n        //cout<<\"\\n\";\n    }\n    cout<<dp[n][w];\n    return 0;\n}```",
        "置物櫃出租```#include<bits/stdc++.h>\nusing namespace std;\n#define N 101\n#define W 200005\nint dp[N][W]={0};\nint main(){\n    int n,m,s,a[N],all=0;\n    cin>>n>>m>>s;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        all+=a[i];\n    }\n    m-=s;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<a[i-1];j++)\n            dp[i][j]=dp[i-1][j];//選不了所以跟上一個情況一樣\n        for(int j=a[i-1];j<=m;j++)\n            dp[i][j]=max(dp[i-1][j],dp[i-1][j-a[i-1]]+a[i-1]);\n    }\n    cout<<all-dp[n][m];\n    return 0;\n}```",
        "楊鐵心做 1 休 K```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint dp[N]={0};\nint main(){\n    int n,k,a[N],mx=0;\n    cin>>n>>k;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    dp[0]=a[0];\n    for(int i=1;i<=k;i++){\n        dp[i]=max(dp[i-1],a[i]);\n    }\n    for(int i=k+1;i<n;i++){\n        dp[i]=max(dp[i-1],a[i]+dp[i-k-1]);\n        mx=max(mx,dp[i]);\n    }\n    cout<<mx;\n    return 0;\n}```",
        "固定長度區間的最大區段差```#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 200005\nint seq[MAXN];\ndeque<int> max_q, min_q;\nvoid put_max(int i){\n    while(max_q.size()!=0 && seq[max_q.back()]<=seq[i])\n        max_q.pop_back();\n    max_q.push_back(i);\n}\nvoid put_min(int i){\n    while(min_q.size()!=0 && seq[min_q.back()]>=seq[i])\n        min_q.pop_back();\n    min_q.push_back(i);\n}\nint main(){\n    int N,L,max_diff=0;\n    cin>>N>>L;\n    for(int i=0;i<N;i++)\n        cin>>seq[i];\n    put_max(0);\n    put_min(0);\n    //第一個數字不用判斷直接丟進去就可以了\n    for(int i=1;i<N;i++){\n        if(max_q.front()<=i-L)\n            max_q.pop_front();//超出範圍\n        put_max(i);\n        if(min_q.front()<=i-L)\n            min_q.pop_front();//超出範圍\n        put_min(i);\n        int diff=seq[max_q.front()]-seq[min_q.front()];\n        max_diff=max(max_diff, diff);\n    }\n    cout<<max_diff;\n    return 0;\n}```",
        "周伯通的基地台 (@@)```#include<bits/stdc++.h>\nusing namespace std;\n#define N 2000005\ndeque<int> min_d;\nint a[N];\nlong long dp[N];\nvoid put_min(int i){\n    while(min_d.size()!=0 && dp[min_d.back()]>=dp[i])\n        min_d.pop_back();\n    min_d.push_back(i);\n}\nint main(){\n    int n,k;\n    cin>>n>>k;\n    for(int i=0;i<n;i++)\n        cin>>a[i];\n    dp[0]=a[0];\n    put_min(0);\n    for(int i=1;i<=k;i++){\n        dp[i]=a[i];\n        put_min(i);\n    }\n    for(int i=k+1;i<n;i++){\n        if(min_d.front()<=i-2*k-2)\n            min_d.pop_front();\n        dp[i]=dp[min_d.front()]+a[i];\n        put_min(i);\n    }\n    while(min_d.front()<=n-2-k)\n        min_d.pop_front();\n    cout<<dp[min_d.front()];\n    return 0;\n}```",
        "一次買賣```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint p[N]={0};\nint main(){\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>p[i];\n    int dp1,dp2;\n    dp1 = 0;//不持有\n    dp2 = -p[0];//持有\n    for(int i=1;i<n;i++){\n        int buffer1,buffer2;//現在不持有跟持有的情況\n        buffer1=max(dp1,dp2+p[i]);\n        buffer2=max(dp2,-p[i]);\n        dp1=buffer1;dp2=buffer2;\n    }\n    cout<<dp1;\n    return 0;\n}```\n這題的寫法跟講義不太一樣,這樣寫應該比較清楚用到動態規劃的地方",
        "K 次買賣```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100001\nint p[N],dp[101][N]={0},max_profit;\nint main(){\n    int n,k;\n    cin>>n>>k;\n    for(int i=0;i<n;i++)\n        cin>>p[i];\n    for(int i=1;i<=k;i++){\n        max_profit= -p[0];\n        for(int j=1;j<n;j++){\n            dp[i][j]=max(dp[i][j-1],max_profit+p[j]);\n            max_profit=max(max_profit,dp[i-1][j]-p[j]);\n        }\n    }\n    cout<<dp[k][n-1];\n    return 0;\n}\n//這題的要點在持有跟不持有兩個狀態```",
        "Hyper-cube path```#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000000\nint c[N],w[N];\nint dp(int goal,int n){\n    if(c[goal]>=0) return c[goal];\n    int imax=0;\n    for(int i=0;i<n;i++){//從0位到n-1位\n        if(goal & (1<<i)){//如果第i位是1\n            int k=dp(goal^(1<<i),n);//把第i位變成0\n            if(k>imax) imax=k;\n        }\n    }\n    c[goal]=imax+w[goal];\n    return c[goal];\n}\nint main(){\n    int i,n,m;\n    cin>>n;\n    m=(1<<n);\n    for(int i=0;i<m;i++)\n        cin>>w[i];\n    memset(c,-1,sizeof(c));\n    c[0]=w[0];\n    cout<<dp(m-1,n);//m-1 = 11....11\n//編號是從0開始所以才要m-1\n}```",
        "合成函數(2)```#include<bits/stdc++.h>\nusing namespace std;\nint eval(){\n    char a[3];\n    int x,y,z;\n    cin>>a;\n    if(a[0]=='f'){\n        x=eval();\n        return (2*x-3);\n    }else if(a[0]=='g'){\n        x=eval();\n        y=eval();\n        return (2*x+y-7);\n    }else if(a[0]=='h'){\n        x=eval();\n        y=eval();\n        z=eval();\n        return (3*x-2*y+z);\n    }else{\n        return atoi(a);\n    }\n}\nint main(){\n    cout<<eval();\n    return 0;\n}```",
        "支點切割```#include<bits/stdc++.h>\nusing namespace std;\n#define  N 50005\ntypedef long long LL;\nLL a[N],K,lps[N],rps[N];//ps:prefix sum\nint cut(int l,int r,int k){\n    if(k>K || r-l<2)\n        return 0;\n    LL buffer=0;\n    lps[l]=0;rps[r]=0;\n    for(int i=l+1;i<r;i++){\n        buffer+=a[i-1];\n        lps[i]=lps[i-1]+buffer;\n    }\n    buffer=0;\n    for(int i=r-1;i>l;i--){\n        buffer+=a[i+1];\n        rps[i]=rps[i+1]+buffer;\n    }\n    buffer=10e8+1;\n    int c;\n    for(int i=r-1;i>l;i--){\n        LL sum;\n        sum=abs(lps[i]-rps[i]);\n        if(sum<=buffer){\n            buffer=sum;\n            c=i;\n        }\n    }\n    return a[c]+cut(l,c-1,k+1)+cut(c+1,r,k+1);\n}\nint main(){\n    int n;\n    cin>>n>>K;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    cout<<cut(0,n-1,1);\n    return 0;\n}```",
        "二維黑白影像編碼(DF-expression)```#include<bits/stdc++.h>\nusing namespace std;\nstring a;\nint k,t=0,sum=0;\nvoid ans(int n){\n    for(int i=1;i<=4;i++){\n        t++;\n        if(a[t]=='1'){\n            sum+=n*n;\n        }else if(a[t]=='2'){\n            ans(n/2);\n        }\n    }\n}\nint main(){\n    cin>>a>>k;\n    if(a[0]=='2')\n        ans(k/2);\n    else if(a[0]=='1')\n        sum=k*k;\n    cout<<sum;\n}```",
        "子集合的和```#include<bits/stdc++.h>\nusing namespace std;\n#define N 26\nint a[N],ans,d[N],n;\nvoid sub(int s,int m){\n    if(s>n || m<0){\n        if(m<ans && m>0)\n            ans=m;\n        return;\n    }\n    sub(s+1,m);\n    sub(s+1,m-a[s]);\n}\nint main(){\n    int p;\n    cin>>n>>p;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    ans=p;\n    sub(1,p);\n    cout<<p-ans;\n    return 0;\n}```",
        "最多得分的皇后```#include<bits/stdc++.h>\nusing namespace std;\n#define N 14\nint q[N][N],n,ans=0,a[N];\nvoid Queen(int k){\n    if(k==n){\n        int buffer=0;\n        for(int i=0;i<n;i++){\n            if(a[i]==-1) continue;\n            buffer+=q[i][a[i]];\n        }\n        if(ans<buffer) ans=buffer;\n    }else{\n        for(int i=0;i<n;i++){\n            bool t=1;\n            for(int j=0;j<k;j++){\n                if(a[j]==-1) continue;\n                if(i==a[j] || abs(a[j]-i)==(k-j)){\n                    t=0;\n                    break;\n                }\n            }\n            if(t){\n                a[k]=i;\n                Queen(k+1);\n            }\n        }\n        a[k]=-1;\n        Queen(k+1);\n    }\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n            cin>>q[i][j];\n    Queen(0);\n    cout<<ans;\n    return 0;\n}```",
        "互補團隊(APCS)```#include<bits/stdc++.h>\nusing namespace std;\n#define N 500005\nmap<long long,int> mp;\nlong long all,buffer;\nint main(){\n    // ios::sync_with_stdio(0);\n    // cin.tie(0);\n    mp.clear();\n    int m,n,t=0;\n    cin>>m>>n;\n    all=(1<<m)-1;\n    for(int i=0;i<n;i++){\n        buffer=0;\n        string a;\n        cin>>a;\n        for(int j=0;j<(int)a.size();j++)\n            if(a[j]>='a'){\n                buffer |= 1LL<<(a[j]-'a'+26);\n            }else\n                buffer |= 1LL<<(a[j]-'A');\n        t+=mp[buffer^all];\n        mp[buffer]++;\n    }\n    cout<<t;\n    return 0;\n}```\n這題解法概念是對的，不過還有一點點細節可以優化",
        "帶著板凳排雞排的高人(APCS)```#include <bits/stdc++.h>\nusing namespace std;\n#define N 200005\nint h[N],p[N];\nlong long all=0;\nvector<pair<int,int>> v;\nint main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>h[i];\n        h[i]*=-1;\n    }\n    for(int i=1;i<=n;i++){\n        cin>>p[i];\n        p[i]*=-1;\n    }\n    v.push_back({-10000005,0});\n    v.push_back({h[1],1});\n    for(int i=2;i<=n;i++){\n        int it=lower_bound(v.begin(),v.end(),make_pair(h[i]+p[i],-1))-v.begin();\n        it-=1;\n        if(it == 0) all+=i-1;\n        else all+=i-v[it].second-1;\n        while(v.size()!=0 && h[i]<v.back().first)\n            v.pop_back();\n        v.push_back(make_pair(h[i],i));\n    }\n    cout<<all;\n    return 0;\n}```",
        "最長的相異色彩帶```#include<bits/stdc++.h>\nusing namespace std;\n#define N 200005\nint a[N],b[N]={0};\nint main(){\n    int n,max1=0;\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>a[i];\n    for(int right=0,left=0,max2=0;right<n;right++){\n        b[a[right]]++;\n        max2++;\n        while(b[a[right]]==2){\n            b[a[left]]--;\n            left++;\n            max2--;\n        }\n        max1=max(max1,max2);\n    }\n    cout<<max1;\n    return 0;\n}```",
        "完美彩帶```#include<bits/stdc++.h>\nusing namespace std;\n#define N 200005\nint b[N]={0},mx=0;\nstring a[N];\nmap<string,int> mp;\nint main(){\n    int m,n,n_color=0;\n    cin>>m>>n;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        mp[a[i]]=0;\n    }\n    for(auto &i:mp){\n        i.second=n_color++;\n    }\n    for(int right=0,left=0,color;right<n;right++){\n        color=mp[a[right]];\n        b[color]++;\n        while(b[color]==2){\n            b[mp[a[left]]]--;\n            left++;\n        }\n        if(right-left+1==m)\n            mx++;\n    }\n    cout<<mx;\n    return 0;\n}```",
        "少林寺的自動寄物櫃(APCS)```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nstruct item{\n    int w,f;\n};\nbool cmp(item p,item q){\n    return p.w*q.f < q.w*p.f;\n}\nint main(){\n    item ite[N];\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>ite[i].w;\n    for(int i=0;i<n;i++)\n        cin>>ite[i].f;\n    sort(ite,ite+n,cmp);\n    long long all=0,buffer=ite[0].w;\n    for(int i=1;i<n;i++){\n        all+=buffer*ite[i].f;\n        buffer+=ite[i].w;\n    }\n    cout<<all;\n    return 0;\n}```",
        "先到先服務 (*)```#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,mx=0;\n    priority_queue<int> pq;\n    cin>>n>>m;\n    for(int i=0,buffer;i<n;i++){\n        cin>>buffer;\n        if((int)pq.size()<m)\n            pq.push(-buffer);\n        else{\n            buffer+=-(pq.top());\n            pq.pop();\n            pq.push(-buffer);\n        }\n        mx=max(mx,buffer);\n    }\n    cout<<mx;\n    return 0;\n}```",
        "恢復能量的白雲熊膽丸```#include <bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint n,m,p[N],mx=0;\nbool enough(int e){\n    if(e<mx) return false;\n    int bm=m,be=e;\n    for(int i=0;i<n;i++){\n        if(be-p[i]<0){\n            if(--bm<0) return false;\n            be=e;\n        }\n        be-=p[i];\n    }\n    return true;\n}\nint main(){\n    int all=0;\n    cin>>n>>m;\n    for(int i=0;i<n;i++){\n        cin>>p[i];\n        mx=max(mx,p[i]);\n        all+=p[i];\n    }\n    int t=0;\n    if(m==0) cout<<all;\n    else\n        for(int jump=all/2;jump>0;jump>>=1){\n            while(t+jump<all && !enough(t+jump))\n                t+=jump;\n        }\n    cout<<++t;\n    return 0;\n}```",
        "死線高手```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nstruct dead{\n    int time,dline;\n};\nbool cmp(dead a,dead b){\n    return a.dline<b.dline;\n}\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    bool ans[25]={0};\n    cin>>t;\n    for(int i=0,n;i<t;i++){\n        cin>>n;\n        dead d[N];\n        for(int j=0;j<n;j++)\n            cin>>d[j].time;\n        for(int j=0;j<n;j++)\n            cin>>d[j].dline;\n        sort(d,d+n,cmp);\n        bool test=1;\n        for(int j=0,now=0;j<n;j++){\n            now+=d[j].time;\n            if(now>d[j].dline){\n                test=0;\n                break;\n            } \n        }\n        if(test) ans[i]=1;\n    }\n    for(int i=0;i<t;i++)\n        if(ans[i]==0)\n            cout<<\"no\\n\";\n        else\n            cout<<\"yes\\n\";\n    return 0;\n}```",
        "賺錢與罰款```#include <bits/stdc++.h>\nusing namespace std;\n#define N 100005\nstruct money{\n    int t,d;\n};\n//依工作時間排序\nbool cmp(money a,money b){\n    return a.t<b.t;\n}\nint main(){\n    int n;\n    long long all=0;\n    money td[N];\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>td[i].t;\n    for(int i=0;i<n;i++)\n        cin>>td[i].d;\n    sort(td,td+n,cmp);\n    for(int i=0,now=0;i<n;i++){\n        now+=td[i].t;\n        all+=td[i].d-now;\n    }\n    cout<<all;\n    return 0;\n}```",
        "少林寺的櫃姐```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint t[N],n,D;\nbool enough(int m){\n    priority_queue<int> pq;\n    int mx=0;\n    for(int i=0,buffer;i<n;i++){\n        buffer=t[i];\n        if((int)pq.size()<m)\n            pq.push(-buffer);\n        else{\n            buffer+=-(pq.top());\n            pq.pop();\n            pq.push(-buffer);\n        }\n        mx=max(mx,buffer);\n        \n    }\n    if(mx>D) return false;\n    else return true;\n}\nint main(){\n    cin>>n>>D;\n    for(int i=0;i<n;i++)\n        cin>>t[i];\n    int tower=0;\n    for(int jump=n/2;jump>0;jump>>=1){\n        while(tower+jump<n && !enough(jump+tower))\n            tower+=jump;\n    }\n    cout<<++tower;\n    return 0;\n}```",
        "五嶽盟主的會議場所```#include<bits/stdc++.h>\nusing namespace std;\n//只有達到80%\n#define N 100005\nstruct guild{\n    int m,s,t;\n};\nbool cmp(guild a,guild b){\n    return a.s<b.s;\n}\nstruct cmp2{\n    bool operator()(guild a, guild b){\n        return a.t<b.t;//需要反向定義\n    }\n};\nguild g[N];\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n,mx=0;\n    priority_queue<guild,vector<guild>,cmp2> pq;\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>g[i].m>>g[i].s>>g[i].t;\n    sort(g,g+n,cmp);\n    for(int i=0,mb;i<n;i++){//mb=maxbuffer\n        mb=0;\n        priority_queue<guild,vector<guild>,cmp2> buffer;\n        mb+=g[i].m;\n        while(!pq.empty()){\n            guild top;\n            top=pq.top();\n            if(g[i].s<=top.t){\n                mb+=top.m;\n            }else{\n                break;\n            }\n            buffer.push(top);\n            pq.pop();\n        }\n        mx=max(mx,mb);\n        pq=buffer;\n        pq.push(g[i]);\n    }\n    cout<<mx;\n    return 0;\n}```",
        "從缺",
        "Closest pair 從缺",
        "完美彩帶 從缺",
        "闖關路線\n用pair可是優化不好只能過部分測資的版本\n```#include <bits/stdc++.h>\nusing namespace std;\n#define N 1000005\nint a[N];\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n,p,l,r;\n    bool visit[N]={0};\n    cin>>n>>p>>l>>r;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        if(a[i]<0 || a[i]>=n)\n            a[i]=n;\n    }\n    queue<pair<int,int>> q;\n    q.push({0,0});\n    int buffer;\n    while(!q.empty() && q.front().first!=p){\n        auto v=q.front();\n        visit[v.first]=1;\n        q.pop();\n        buffer=v.first-l;\n        if(buffer>=0 && a[buffer]!=n && visit[a[buffer]]!=1)\n            q.push({a[buffer],v.second+1});\n        buffer=v.first+r;\n        if(buffer<n && a[buffer]!=n && visit[a[buffer]]!=1)\n            q.push({a[buffer],v.second+1});\n    }\n    cout<<q.front().second;\n    return 0;\n}```\n成功的版本```#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\nconst int maxn = 1000005;\nint n, p, l, r, a[maxn], d[maxn], now, nxt;\n  \nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    while (cin >> n >> p >> l >> r) {\n        for (int i = 0; i < n; i++){\n        cin >> a[i];\n        if (a[i] >= n || a[i] < 0) a[i] = n;\n    }\n    memset(d, -1, sizeof(d));\n    d[0] = 0;\n    queue <int> q;\n    q.push(0);\n    while (!q.empty() && d[p] == -1){\n        now = q.front();\n        q.pop();\n        nxt = now - l;\n        if (nxt >= 0 && a[nxt] != n && d[a[nxt]] == -1){\n            d[a[nxt]] = d[now] + 1;\n            q.push(a[nxt]);\n        }\n        nxt = now + r;\n        if (nxt < n && a[nxt] != n && d[a[nxt]] == -1){\n            d[a[nxt]] = d[now] + 1;\n            q.push(a[nxt]);\n        }\n    }\n    cout << d[p] << \"\\n\";\n    }\n    return 0;\n}```",
        "紅白彩帶(APCS)```#include <bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint p[N],maxn=0;\nbool color[N];\nmultiset<int> mst;\nint find(int x){\n    if(p[x]<0)\n        return x;\n    return p[x]=find(p[x]);\n}\nvoid unionn(int x,int y){\n    int r1=find(x);\n    int r2=find(y);\n    auto it=mst.find(-p[r1]);\n    mst.erase(it);\n    it=mst.find(-p[r2]);\n    mst.erase(it);\n    if(p[r1]>p[r2]){\n        p[r2]+=p[r1];\n        p[r1]=r2;\n        mst.insert(-p[r2]);\n        maxn=max(maxn,-p[r2]);\n    }else{\n        p[r1]+=p[r2];\n        p[r2]=r1;\n        mst.insert(-p[r1]);\n        maxn=max(maxn,-p[r1]);\n    }\n}\nint main(){\n    int n,k;\n    cin>>n>>k;\n    for(int i=1;i<=n;i++){\n        cin>>color[i];\n        if(color[i]){\n            p[i]=-1;\n            mst.insert(1);\n            if(color[i-1]==1) unionn(i,i-1);\n        }\n    }\n    int mx=*mst.rbegin(),mn=*mst.begin();\n    for(int i=0,temp;i<k;i++){\n        cin>>temp;\n        color[temp]=1;\n        p[temp]=-1;\n        mst.insert(1);\n        for(int j=-1;j<2;j+=2){\n            if(color[temp+j]) unionn(temp,temp+j);\n        }\n        mx+=maxn;\n        mn+=*mst.begin();\n    }\n    cout<<mx<<\"\\n\"<<mn;\n    return 0;\n}```",
        "樹狀圖的距離總和```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint n,w[N],num[N]={0};\nlong long total=0,dis_son[N]={0},dis[N]={0};\nvector<int> child[N];\nvoid dfs(int p){//O(n)\n    for(auto e:child[p]){\n        int u=e;\n        dfs(u);\n        dis_son[p]+=dis_son[u]+num[u]*w[u];\n        num[p]+=num[u];\n    }\n    num[p]++;\n}\nvoid dfs_dis(int p){//O(n)\n    for(auto e:child[p]){\n        int u=e;\n        dis[u]=dis[p]-(dis_son[u]+num[u]*w[u])+(n-num[u])*w[u]+dis_son[u];\n        total+=dis[u];\n        dfs_dis(e);\n    }\n}\nqueue<int> q;\nvoid bfs_dis(){//算總和的時候bfs程式碼\n    while(!q.empty()){\n        int p=q.front();\n        q.pop();\n        for(auto t:child[p]){\n            int u=t;\n            q.push(u);\n            dis[u]=dis[p]-(dis_son[u]+num[u]*w[u])+(n-num[u])*w[u]+dis_son[u];\n            total+=dis[u];\n        }\n    }\n}\nint main(){\n    cin>>n;\n    for(int i=2,temp;i<=n;i++){\n        cin>>temp;\n        child[temp].push_back(i);\n    }\n    for(int i=2;i<=n;i++)\n        cin>>w[i];\n    dfs(1);\n    dis[1]=dis_son[1];\n\n    dfs_dis(1);\n\n    // q.push(1);\n    // bfs_dis();\n\n    cout<<total+dis_son[1];\n}```",
        "服務中心選位置```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nint total=0,chose[N]={0};\nvector<int> path[N];\nvoid dfs(int r,int p){//p = parent\n    for(auto e:path[r]){\n        if(e==p) continue;\n        dfs(e,r);\n        if(chose[r]==1)\n            chose[e]=1;\n        else if(chose[e]==0){\n            if(p!=-1 && chose[p]==0) chose[p]=2;\n            chose[r]=1;\n            chose[e]=1;\n            total++;\n        }\n    }\n}\nint main(){\n    int n,num[N]={1},point=1;\n    cin>>n;\n    for(int i=1,u,v;i<n;i++){\n        cin>>u>>v;\n        num[u]++;\n        num[v]++;\n        path[u].push_back(v);\n        path[v].push_back(u);\n        if(num[u]>num[point]) point=u;\n        if(num[v]>num[point]) point=v;\n    }\n    dfs(point,-1);\n    if(chose[point]==0){\n        total++;\n    } \n    cout<<total;\n    return 0;\n}\n```",
        "佔領連續的城鎮```#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nvector<int> child[N];\nlong long mx=0,sum[N]={0},w[N];\nvoid dfs(int v,int p){\n    for(auto e:child[v]){\n        if(e==p) continue;\n        dfs(e,v);\n        sum[v]=max(sum[v],sum[v]+sum[e]);\n        mx=max(mx,sum[v]);\n    }\n}\nint main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        cin>>w[i];\n        sum[i]=w[i];\n    }\n    for(int i=1,u,v;i<n;i++){\n        cin>>u>>v;\n        child[u].push_back(v);\n        child[v].push_back(u);\n    }\n    dfs(1,-1);\n    cout<<mx;\n    return 0;\n}```",
        "樹上一位不回家的推銷員```#include<bits/stdc++.h>\nusing namespace std;\n#define N 500005\nvector<pair<int,int>> adj[N];\nint dis[N]={0};\nvoid dfs_dis(int v,int p){\n    for(auto e:adj[v]){\n        int u=e.first,w=e.second;\n        if(u==p) continue;\n        dis[u]+=dis[v]+w;\n        dfs_dis(u,v);\n    }\n}\nint dis_temp[N]={0};\nvoid dfs_disw(int v,int p){\n    for(auto e:adj[v]){\n        int u=e.first,w=e.second;\n        if(u==p) continue;\n        dis_temp[u]+=dis_temp[v]+w;\n        dfs_disw(u,v);\n        dis[v]+=dis[u]+w;\n    }\n}\nint main(){\n    int n;\n    cin>>n;\n    for(int i=1,u,v,w;i<n;i++){\n        cin>>u>>v>>w;\n        adj[u].push_back({v,w});\n        adj[v].push_back({u,w});\n    }\n    dfs_dis(1,-1);\n    int farthest=max_element(dis,dis+n)-dis;//取點\n    memset(dis,0,sizeof(dis));\n    dfs_disw(farthest,-1);\n    int mx=dis[farthest];\n    farthest=*max_element(dis_temp,dis_temp+n);//取值\n    mx=mx*2-farthest;\n    cout<<mx;\n    return 0;\n}```"
    ],
    "keyword": [
        "BFS",
        "DFS",
        "Binary search",
        "vector",
        "map",
        "set",
        "sort",
        "C優化"
    ],
    "value": [
        "```bool visit[n]={0};\nmap<int,vector<int>> mp;\nqueue<int> q; q.push(start);\nvisit[start]=true;\nwhile(q.size() > 0){\n    int v=q.front();\n    q.pop();\n    for(int u:mp[v]){\n        if(visit[u]!=true){\n            visit[u]=true;\n             q.push(u);\n         }\n     }\n }```",
        "```map<int,vector<int>> mp;\nbool visit[200]={0};\nvoid dfs(int p){\n    visit[p]=1;\n    for(int u:mp[p]){\n        if(visit[u]!=1)\n            dfs(u);\n    }\n    return;\n}```",
        "```// 跳躍法二分搜\n// 假設遞增值存於 p[]，在 p[s]~p[t]找到最後一個 < x 的位置\nk = s; // k 存目前位置, jump 是每次要往前跳的距離，逐步所減\nfor (jump = (t – s)/2; jump>0; jump /= 2) {\n    while (k+jump<t && p[k+jump]<x) // 還能往前跳就跳\n        k += jump;\n}\n-=-=-=-=-=-=-\nSTL函數必須在數組由小到大才可搜尋\n如果數組由大到小可以嘗試把數組都變成負的`\nlower_bound：找出vector中「大於或等於」val的「最小值」的位置：\n    auto it = lower_bound(v.begin(), v.end(), val);\n    auto it = lower_bound(v+0, v+n, val);//陣列\nupper_bound：找出vector中「大於」val的「最小值」的位置：\n    auto it = upper_bound(v.begin(), v.end(), val);\n    auto it = upper_bound(v+0, v+n, val);//陣列```",
        "```宣告：\nvector<int> v; 宣告一個空的vector，長度不定。\nvector<int> v(5); 宣告一個長度為 5 的vector。\nvector<int> v(5, 0); 宣告一個長度為 5 的vector，且每個元素的初始值為 0。\nvector<int> v2 = v; 宣告一個新的vector v2，並賦予v的內容。\nvector<int> v3[2]; 宣告兩個空的vectors，分別是v3[0]、v3[1]。\n取值：\n與陣列相同，透過下標取值，例如v[0]為vector v中index=0對應的元素，v[1]為vector v中index=1對應的元素，以此類推。\nv.front()：取出vector v 中的第一個元素。\nv.back()：取出vector v 中的最後一個元素。\n把元素加進vector：\nv.push_back(x)：在vector v的尾端增添一個元素x。\n把元素插入vector：\nv.insert(v.begin() + i, x)：在vector v中 index=i 的位置放進x，原本在 index=i 的元素及其後的所有元素，後推一個位置。\n刪除元素：\nv.pop_back()：刪除最後一個元素\nv.erase(v.begin()+i)：刪除 index=i 的元素\nv.erase(v.begin(), v.begin()+i)：刪除 index=0 到 index=i (不含)的元素\nv.clear()：清空整個vector\n判斷vector的長度：\nv.size()\n判斷是否為空的vector：\nv.empty() 回傳true\nv.size() 回傳零```",
        "```【map】搜尋紅黑樹，O(log(N))\nmap：存放 key-value pairs 的映射資料結構，會按 key 由小到大排序。\n宣告：\nmap <int, int> mp; // key和value都是整數\nmap<int,pair<int,int>> mp;\nmap <int, vector<int>> mp;\nmap<int,vector<pair<int,int>>> mp;\n加入新的key-value pair：\nmp[key] = value;\nmp[key].push_back(value1);\nmp[key].push_back({value1,value2});\n檢查 key 是否存在 map 中：\nmp.count(key);\n刪除 key：\nmp.erase(key);\n清空 map 中的所有元素：\nmp.clear();\n利用 key 取值：\nvalue = mp[key];//value 不是pair才可以\nvalue = mp[key].first;\nvalue = mp[key].second;\n遍歷整個map時，利用iterator操作：\n取key：it->first 或 (*it).first\n取value：it->second 或 (*it).second\n判斷是否為空的map：\nmp.empty() 回傳true\nmp.size() 回傳零\n用for迴圈遍歷:\nfor(auto it:mp[key])```",
        "```\n【set】\nset：集合，去除重複的元素，資料由小到大排序。\n宣告：\nset <int> st;\n把元素 x 加進 set：\nst.insert(x);\n檢查元素 x 是否存在 set 中：\nst.count(x);\n刪除元素 x：\nst.erase(x); // 可傳入值或iterator\n清空集合中的所有元素：\nst.clear();\n取值：使用iterator\nx = st.begin(); // set 中的第一個元素(最小的元素)。\nx =st.rbegin(); // set 中的最後一個元素(最大的元素)。\n判斷是否為空的set：\nst.empty() 回傳true\nst.size() 回傳零\n常用來搭配的member function：\nst.count(x);\nauto it = st.find(x); // binary search, O(log(N))\nauto it = st.lower_bound(x); // binary search, O(log(N))\nauto it = st.upper_bound(x); // binary search, O(log(N))\n【multiset】\n與 set 用法雷同，但會保留重複的元素，資料由小到大排序。\n宣告：\nmultiset<int> st;\n刪除資料：\nst.erase(val); 會刪除所有值為 val 的元素。\nst.erase(st.find(val)); 只刪除第一個值為 val 的元素。 ```",
        "```【array】\n    給定陣列 a[ ]，陣列長度為 N。\nsort(a, a+N); //就地排序，無回傳值。\nsort(a, a+N, cmp); //自行定義 cmp 函式，決定排序方法。\n【vector】\n    給定動態陣列 v[ ]。\nsort(v.begin(), v.end()); //就地由小到大排序，無回傳值。\nsort(v.begin(), v.end(), cmp); //自行定義 cmp 函式，決定排序方法。\nsort(v.rbegin(), v.rend()); //就地由大到小排序，無回傳值。\nbool cmp(int &s, int &t) {\n    return s>t;\n}//此範例是由大到小,改由小到大只須把大於改小於```",
        "```ios::sync_with_stdio(0);\ncin.tie(0);```"
    ],
    "pword": [],
    "preposition": [],
    "temp": [
        "nothing",
        "Hello",
        "Hello",
        "Hello",
        "Hello",
        "Hello"
    ],
    "set": "```// 跳躍法二分搜\n// 假設遞增值存於 p[]，在 p[s]~p[t]找到最後一個 < x 的位置\nk = s; // k 存目前位置, jump 是每次要往前跳的距離，逐步所減\nfor (jump = (t – s)/2; jump>0; jump /= 2) {\n    while (k+jump<t && p[k+jump]<x) // 還能往前跳就跳\n        k += jump;\n}\n-=-=-=-=-=-=-\nSTL函數必須在數組由小到大才可搜尋\n如果數組由大到小可以嘗試把數組都變成負的`\nlower_bound：找出vector中「大於或等於」val的「最小值」的位置：\n    auto it = lower_bound(v.begin(), v.end(), val);\n    auto it = lower_bound(v+0, v+n, val);//陣列\nupper_bound：找出vector中「大於」val的「最小值」的位置：\n    auto it = upper_bound(v.begin(), v.end(), val);\n    auto it = upper_bound(v+0, v+n, val);//陣列```"
}